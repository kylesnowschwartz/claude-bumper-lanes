#!/usr/bin/env bash
# git-diff-tree: Hierarchical diff visualization with stats
#
# Algorithm based on eza/ftdv pattern:
# 1. Build tree structure from sorted paths
# 2. Flatten with DFS, tracking parent_is_last[] at each depth
# 3. Render prefix from parent_is_last[], add connector based on is_last
#
# Usage:
#   git-diff-tree                    # Working tree vs HEAD
#   git-diff-tree --cached           # Staged changes
#   git-diff-tree HEAD~5 HEAD        # Compare refs
#   git-diff-tree main feature       # Compare branches
#
# Options:
#   --no-color    Disable colored output
#   --summary     Only show totals, no tree
#
set -euo pipefail

# Defaults
USE_COLOR=true
SUMMARY_ONLY=false
DIFF_ARGS=""

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-color) USE_COLOR=false; shift ;;
        --summary) SUMMARY_ONLY=true; shift ;;
        *) DIFF_ARGS+=" $1"; shift ;;
    esac
done
DIFF_ARGS="${DIFF_ARGS# }"

# Colors
if $USE_COLOR; then
    C_DIR="\e[34m"       # Blue for directories
    C_FILE="\e[38;5;8m"  # Dark gray (fg 8) for files
    C_ADD="\e[32m"       # Green for additions
    C_DEL="\e[31m"       # Red for deletions
    C_RST="\e[0m"        # Reset
else
    C_DIR=""; C_FILE=""; C_ADD=""; C_DEL=""; C_RST=""
fi

# Default diff args
[[ -z "$DIFF_ARGS" ]] && DIFF_ARGS="HEAD"

# Get diff data
mapfile -t lines < <(git diff --numstat $DIFF_ARGS 2>/dev/null || true)

if [[ ${#lines[@]} -eq 0 ]]; then
    echo "No changes"
    exit 0
fi

# Parse into arrays
declare -A file_add file_del
declare -a all_paths

for line in "${lines[@]}"; do
    read -r add del path <<< "$line"
    [[ -z "$path" ]] && continue
    all_paths+=("$path")
    file_add["$path"]="${add//-/B}"
    file_del["$path"]="${del//-/B}"
done

# Sort paths
IFS=$'\n' sorted=($(sort <<< "${all_paths[*]}")); unset IFS
total=${#sorted[@]}

# Calculate totals
calc_totals() {
    local total_add=0 total_del=0
    for path in "${sorted[@]}"; do
        local a="${file_add[$path]}" d="${file_del[$path]}"
        [[ "$a" != "B" ]] && ((total_add += a)) || true
        [[ "$d" != "B" ]] && ((total_del += d)) || true
    done
    echo "$total_add $total_del"
}

# Summary only mode
if $SUMMARY_ONLY; then
    read -r total_add total_del <<< "$(calc_totals)"
    echo -e "${C_ADD}+${total_add}${C_RST} ${C_DEL}-${total_del}${C_RST} in ${total} files"
    exit 0
fi

# =============================================================================
# Simpler approach: Process sorted paths, emit dirs on first encounter
# Track parent_is_last[] for prefix generation
# =============================================================================

declare -A seen_dirs
declare -a parent_is_last

# Pre-compute: for each path component at each depth, is it the last sibling?
# We do this by scanning ahead in the sorted list

# Get all unique "tree items" (dirs + files) in display order
declare -a tree_items  # Each: "depth|full_path|name|is_dir"

for path in "${sorted[@]}"; do
    IFS='/' read -ra parts <<< "$path"

    # Emit any unseen directories first
    dir_path=""
    for ((i=0; i<${#parts[@]}-1; i++)); do
        if [[ -n "$dir_path" ]]; then
            dir_path="$dir_path/${parts[i]}"
        else
            dir_path="${parts[i]}"
        fi

        if [[ -z "${seen_dirs[$dir_path]:-}" ]]; then
            seen_dirs["$dir_path"]=1
            tree_items+=("$i|$dir_path|${parts[i]}|1")
        fi
    done

    # Emit the file
    tree_items+=("$((${#parts[@]}-1))|$path|${parts[-1]}|0")
done

# Now compute is_last for each item by looking at what follows
total_items=${#tree_items[@]}

for ((idx=0; idx<total_items; idx++)); do
    IFS='|' read -r depth full_path name is_dir <<< "${tree_items[idx]}"

    # Determine parent path for this item
    if [[ "$is_dir" == "1" ]]; then
        parent_path="${full_path%/*}"
        [[ "$parent_path" == "$full_path" ]] && parent_path=""
    else
        parent_path="${full_path%/*}"
        [[ "$parent_path" == "$full_path" ]] && parent_path=""
    fi

    # Check if there's another item at the same depth with the same parent after this one
    is_last=1
    for ((k=idx+1; k<total_items; k++)); do
        IFS='|' read -r k_depth k_path k_name k_is_dir <<< "${tree_items[k]}"

        # Skip if deeper (children)
        [[ "$k_depth" -gt "$depth" ]] && continue

        # If same depth, check parent
        if [[ "$k_depth" == "$depth" ]]; then
            k_parent="${k_path%/*}"
            [[ "$k_parent" == "$k_path" ]] && k_parent=""

            if [[ "$k_parent" == "$parent_path" ]]; then
                is_last=0
            fi
        fi
        break  # Only need to check immediate next item at same or higher level
    done

    # Build prefix using parent_is_last
    prefix=""
    for ((d=0; d<depth; d++)); do
        if [[ "${parent_is_last[$d]:-0}" == "1" ]]; then
            prefix+="    "
        else
            prefix+="│   "
        fi
    done

    # Connector
    if [[ "$is_last" == "1" ]]; then
        connector="└── "
    else
        connector="├── "
    fi

    # Update parent_is_last for this depth
    parent_is_last[$depth]=$is_last

    # Render
    if [[ "$is_dir" == "1" ]]; then
        echo -e "${prefix}${connector}${C_DIR}${name}/${C_RST}"
    else
        add="${file_add[$full_path]:-0}"
        del="${file_del[$full_path]:-0}"
        stat=""
        [[ "$add" != "0" ]] && stat+="${C_ADD}+${add}${C_RST}"
        [[ "$del" != "0" ]] && { [[ -n "$stat" ]] && stat+=" "; stat+="${C_DEL}-${del}${C_RST}"; }
        echo -e "${prefix}${connector}${C_FILE}${name}${C_RST} ${stat}"
    fi
done

# Summary line
read -r total_add total_del <<< "$(calc_totals)"
echo ""
echo -e "${C_ADD}+${total_add}${C_RST} ${C_DEL}-${total_del}${C_RST} in ${total} files"
