package hooks

import (
	"os"
	"path/filepath"
	"testing"
)

func TestIsOurWrapper(t *testing.T) {
	// Create temp dir for test files
	tmpDir := t.TempDir()

	// Create a file with our marker
	markerFile := filepath.Join(tmpDir, "with-marker.sh")
	if err := os.WriteFile(markerFile, []byte("#!/bin/bash\n"+wrapperMarker+" - DO NOT EDIT\necho hello"), 0755); err != nil {
		t.Fatal(err)
	}

	// Create a file without our marker
	noMarkerFile := filepath.Join(tmpDir, "no-marker.sh")
	if err := os.WriteFile(noMarkerFile, []byte("#!/bin/bash\necho hello"), 0755); err != nil {
		t.Fatal(err)
	}

	// Create a file with our exact wrapper filename
	wrapperFile := filepath.Join(tmpDir, wrapperFileName)
	if err := os.WriteFile(wrapperFile, []byte("#!/bin/bash\necho wrapper"), 0755); err != nil {
		t.Fatal(err)
	}

	// Create a fake binary that contains the marker (simulates the compiled Go binary)
	// This should NOT match because it doesn't start with a shebang
	binaryWithMarker := filepath.Join(tmpDir, "bumper-lanes")
	binaryContent := []byte{0x7f, 'E', 'L', 'F'} // ELF magic number
	binaryContent = append(binaryContent, []byte("garbage"+wrapperMarker+"more garbage")...)
	if err := os.WriteFile(binaryWithMarker, binaryContent, 0755); err != nil {
		t.Fatal(err)
	}

	tests := []struct {
		name string
		cmd  string
		want bool
	}{
		{"empty cmd", "", false},
		{"nonexistent file", "/nonexistent/path/script.sh", false},
		{"file with marker", markerFile, true},
		{"file without marker", noMarkerFile, false},
		{"wrapper filename match", wrapperFile, true},
		{"wrapper filename in different dir", filepath.Join("/some/other/path", wrapperFileName), true}, // filename match, file doesn't need to exist
		{"binary with marker embedded", binaryWithMarker, false},                                        // binary contains marker but no shebang
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := isOurWrapper(tt.cmd, tmpDir)
			if got != tt.want {
				t.Errorf("isOurWrapper(%q, %q) = %v, want %v", tt.cmd, tmpDir, got, tt.want)
			}
		})
	}
}

func TestGenerateWrapper(t *testing.T) {
	tmpDir := t.TempDir()
	wrapperPath := filepath.Join(tmpDir, "test-wrapper.sh")
	originalCmd := "/usr/bin/my-status-line"

	err := generateWrapper(wrapperPath, originalCmd, tmpDir)
	if err != nil {
		t.Fatalf("generateWrapper() error = %v", err)
	}

	// Read generated wrapper
	content, err := os.ReadFile(wrapperPath)
	if err != nil {
		t.Fatalf("failed to read wrapper: %v", err)
	}

	contentStr := string(content)

	// Check marker is present
	if !contains(contentStr, wrapperMarker) {
		t.Error("wrapper missing marker")
	}

	// Check BUMPER_BIN marker is present
	if !contains(contentStr, "# BUMPER_BIN: ") {
		t.Error("wrapper missing BUMPER_BIN marker")
	}

	// Check original command is referenced
	if !contains(contentStr, originalCmd) {
		t.Error("wrapper missing original command")
	}

	// Check it's executable
	info, err := os.Stat(wrapperPath)
	if err != nil {
		t.Fatalf("failed to stat wrapper: %v", err)
	}
	if info.Mode().Perm()&0100 == 0 {
		t.Error("wrapper is not executable")
	}
}

func TestGetWrapperBinaryPath(t *testing.T) {
	tmpDir := t.TempDir()

	t.Run("extracts BUMPER_BIN from wrapper", func(t *testing.T) {
		wrapperPath := filepath.Join(tmpDir, "wrapper-with-bin.sh")
		content := `#!/bin/bash
# Generated by bumper-lanes - DO NOT EDIT
# BUMPER_BIN: /path/to/bumper-lanes
# Original command: /usr/bin/my-status
echo hello`
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			t.Fatal(err)
		}

		got := getWrapperBinaryPath(wrapperPath)
		want := "/path/to/bumper-lanes"
		if got != want {
			t.Errorf("getWrapperBinaryPath() = %q, want %q", got, want)
		}
	})

	t.Run("returns empty for missing marker", func(t *testing.T) {
		wrapperPath := filepath.Join(tmpDir, "wrapper-no-bin.sh")
		content := `#!/bin/bash
# Generated by bumper-lanes - DO NOT EDIT
echo hello`
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			t.Fatal(err)
		}

		got := getWrapperBinaryPath(wrapperPath)
		if got != "" {
			t.Errorf("getWrapperBinaryPath() = %q, want empty string", got)
		}
	})

	t.Run("returns empty for nonexistent file", func(t *testing.T) {
		got := getWrapperBinaryPath("/nonexistent/path.sh")
		if got != "" {
			t.Errorf("getWrapperBinaryPath() = %q, want empty string", got)
		}
	})
}

func TestGetOriginalCommand(t *testing.T) {
	tmpDir := t.TempDir()

	t.Run("extracts original command from wrapper", func(t *testing.T) {
		wrapperPath := filepath.Join(tmpDir, "wrapper.sh")
		content := `#!/bin/bash
# Generated by bumper-lanes - DO NOT EDIT
# BUMPER_BIN: /path/to/bumper-lanes
# Original command: /usr/bin/my-custom-status
echo hello`
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			t.Fatal(err)
		}

		got := getOriginalCommand(wrapperPath)
		want := "/usr/bin/my-custom-status"
		if got != want {
			t.Errorf("getOriginalCommand() = %q, want %q", got, want)
		}
	})

	t.Run("returns empty for missing marker", func(t *testing.T) {
		wrapperPath := filepath.Join(tmpDir, "wrapper-no-orig.sh")
		content := `#!/bin/bash
echo hello`
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			t.Fatal(err)
		}

		got := getOriginalCommand(wrapperPath)
		if got != "" {
			t.Errorf("getOriginalCommand() = %q, want empty string", got)
		}
	})
}

func TestIsWrapperStale(t *testing.T) {
	tmpDir := t.TempDir()

	t.Run("stale when BUMPER_BIN differs from current", func(t *testing.T) {
		wrapperPath := filepath.Join(tmpDir, "stale-wrapper.sh")
		// Use a path that definitely won't match the current binary
		content := `#!/bin/bash
# Generated by bumper-lanes - DO NOT EDIT
# BUMPER_BIN: /old/path/to/bumper-lanes
# Original command: /usr/bin/my-status
echo hello`
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			t.Fatal(err)
		}

		if !isWrapperStale(wrapperPath) {
			t.Error("isWrapperStale() = false, want true for different path")
		}
	})

	t.Run("stale when BUMPER_BIN marker missing (old format)", func(t *testing.T) {
		wrapperPath := filepath.Join(tmpDir, "old-format-wrapper.sh")
		content := `#!/bin/bash
# Generated by bumper-lanes - DO NOT EDIT
# Original command: /usr/bin/my-status
echo hello`
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			t.Fatal(err)
		}

		if !isWrapperStale(wrapperPath) {
			t.Error("isWrapperStale() = false, want true for missing BUMPER_BIN marker")
		}
	})

	t.Run("not stale when BUMPER_BIN matches current", func(t *testing.T) {
		wrapperPath := filepath.Join(tmpDir, "current-wrapper.sh")
		currentBin := getBumperLanesBinPath()
		content := `#!/bin/bash
# Generated by bumper-lanes - DO NOT EDIT
# BUMPER_BIN: ` + currentBin + `
# Original command: /usr/bin/my-status
echo hello`
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			t.Fatal(err)
		}

		if isWrapperStale(wrapperPath) {
			t.Errorf("isWrapperStale() = true, want false when BUMPER_BIN matches current (%s)", currentBin)
		}
	})
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsHelper(s, substr))
}

func containsHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
