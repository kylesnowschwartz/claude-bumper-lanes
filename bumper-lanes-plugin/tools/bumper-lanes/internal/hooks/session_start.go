package hooks

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/kylesnowschwartz/claude-bumper-lanes/bumper-lanes-plugin/tools/bumper-lanes/internal/config"
	"github.com/kylesnowschwartz/claude-bumper-lanes/bumper-lanes-plugin/tools/bumper-lanes/internal/state"
)

const (
	// wrapperFileName is the generated status line wrapper script name.
	wrapperFileName = "bumper-lanes-statusline-wrapper.sh"
	// wrapperMarker identifies scripts generated by bumper-lanes.
	wrapperMarker = "# Generated by bumper-lanes"
)

// SessionStart handles the SessionStart hook event.
// It captures the baseline tree and initializes session state.
// Returns exit code: 0 = success, 1 = warning (shows stderr to user).
func SessionStart(input *HookInput) int {
	// Check if this is a git repository
	if !IsGitRepo() {
		return 0 // Fail open - not a git repo
	}

	// Capture baseline tree
	baselineTree, err := CaptureTree()
	if err != nil {
		return 0 // Fail open
	}

	// Get current branch for staleness detection
	baselineBranch := GetCurrentBranch()

	// Load threshold from config
	threshold := config.LoadThreshold()

	// Create and save session state
	sess, err := state.New(input.SessionID, baselineTree, baselineBranch, threshold)
	if err != nil {
		return 0 // Fail open
	}

	// Load persisted view settings from config
	sess.SetViewMode(config.LoadViewMode())
	sess.SetViewOpts(config.LoadViewOpts())

	if err := sess.Save(); err != nil {
		return 0 // Fail open
	}

	// Auto-setup status line wrapper (once per user)
	if msg := setupStatusLineWrapper(); msg != "" {
		fmt.Fprintln(os.Stderr, msg)
		return 1 // Exit 1 shows stderr as warning
	}

	return 0
}

// hasStatusLineConfigured checks if ~/.claude/settings.json has statusLine configured.
func hasStatusLineConfigured() bool {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return true // Assume configured on error (fail open)
	}

	settingsPath := filepath.Join(homeDir, ".claude", "settings.json")
	data, err := os.ReadFile(settingsPath)
	if err != nil {
		return false // No settings file = not configured
	}

	var settings map[string]interface{}
	if err := json.Unmarshal(data, &settings); err != nil {
		return true // Invalid JSON - fail open
	}

	// Check for statusLine key
	statusLine, ok := settings["statusLine"]
	if !ok {
		return false
	}

	// Check if statusLine has a command configured
	statusLineMap, ok := statusLine.(map[string]interface{})
	if !ok {
		return false
	}

	cmd, ok := statusLineMap["command"]
	if !ok {
		return false
	}

	// Non-empty command = configured
	cmdStr, ok := cmd.(string)
	return ok && cmdStr != ""
}

// setupStatusLineWrapper generates a wrapper script and updates settings.json.
// Returns a message to show to user, or empty string if no action needed.
// This is idempotent - checks actual state each time rather than caching.
func setupStatusLineWrapper() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "" // Fail open
	}

	// Get current status line command
	currentCmd := getStatusLineCommand(homeDir)

	// Check if already using our wrapper
	if isOurWrapper(currentCmd, homeDir) {
		// Check if wrapper needs regeneration (plugin updated, path changed)
		if !isWrapperStale(currentCmd) {
			return "" // Already set up and current
		}
		// Stale wrapper - regenerate with updated binary path
		originalCmd := getOriginalCommand(currentCmd)
		if originalCmd == "" {
			return "" // Can't determine original, leave as-is
		}
		if err := generateWrapper(currentCmd, originalCmd, homeDir); err != nil {
			return "" // Fail open - old wrapper still works
		}
		return "[bumper-lanes] Updated status line wrapper for new plugin version. Restart session to activate."
	}

	// Check if already using our binary directly (no custom status line case)
	if isOurBinary(currentCmd) {
		if !isBinaryStale(currentCmd) {
			return "" // Already set up and current
		}
		// Stale binary path - update settings.json to point to new path
		newBinaryPath, err := os.Executable()
		if err != nil {
			return "" // Fail open
		}
		if err := updateSettingsWithJq(homeDir, newBinaryPath); err != nil {
			return "" // Fail open - old binary might still work
		}
		return "[bumper-lanes] Updated status line for new plugin version. Restart session to activate."
	}

	// No existing status line - point directly at binary (outputs full status line)
	if currentCmd == "" {
		binaryPath, err := os.Executable()
		if err != nil {
			return fmt.Sprintf("[bumper-lanes] Couldn't find binary path: %v", err)
		}
		if err := updateSettingsWithJq(homeDir, binaryPath); err != nil {
			return fmt.Sprintf("[bumper-lanes] Couldn't update settings: %v\nRun /bumper-setup-statusline for manual setup.", err)
		}
		return "[bumper-lanes] Status line configured! Restart session to see diff tree."
	}

	// Existing status line - generate wrapper to preserve + extend it
	wrapperPath := filepath.Join(homeDir, ".claude", wrapperFileName)
	if err := generateWrapper(wrapperPath, currentCmd, homeDir); err != nil {
		return fmt.Sprintf("[bumper-lanes] Failed to create wrapper: %v\nRun /bumper-setup-statusline for manual setup.", err)
	}

	if err := updateSettingsWithJq(homeDir, wrapperPath); err != nil {
		return fmt.Sprintf("[bumper-lanes] Wrapper created at %s\nCouldn't update settings: %v\nRun /bumper-setup-statusline for manual setup.", wrapperPath, err)
	}

	return fmt.Sprintf("[bumper-lanes] Wrapped your status line for diff tree. Restart session to activate.\nOriginal: %s", currentCmd)
}

// getStatusLineCommand reads the current statusLine.command from settings.json.
func getStatusLineCommand(homeDir string) string {
	settingsPath := filepath.Join(homeDir, ".claude", "settings.json")
	data, err := os.ReadFile(settingsPath)
	if err != nil {
		return ""
	}

	var settings map[string]interface{}
	if err := json.Unmarshal(data, &settings); err != nil {
		return ""
	}

	statusLine, ok := settings["statusLine"].(map[string]interface{})
	if !ok {
		return ""
	}

	cmd, ok := statusLine["command"].(string)
	if !ok {
		return ""
	}
	return cmd
}

// isOurWrapper checks if the given command is already our generated wrapper.
// Detects by filename match or by marker in file content.
// IMPORTANT: Must verify file is a shell script, not a binary (the binary
// contains the marker string in its compiled code, causing false positives).
func isOurWrapper(cmd, homeDir string) bool {
	if cmd == "" {
		return false
	}

	// Check filename
	if filepath.Base(cmd) == wrapperFileName {
		return true
	}

	// Check file content for marker - but only if it's a shell script
	data, err := os.ReadFile(cmd)
	if err != nil {
		return false
	}

	content := string(data)

	// Must start with shebang to be a shell script (not a binary)
	if !strings.HasPrefix(content, "#!") {
		return false
	}

	return strings.Contains(content, wrapperMarker)
}

// binaryFileName is the bumper-lanes binary name.
const binaryFileName = "bumper-lanes"

// isOurBinary checks if the given command is our binary directly.
func isOurBinary(cmd string) bool {
	if cmd == "" {
		return false
	}
	return filepath.Base(cmd) == binaryFileName
}

// isBinaryStale checks if the binary path is stale (plugin updated).
// Returns true if the path doesn't match the current executable.
func isBinaryStale(cmd string) bool {
	currentBinaryPath, err := os.Executable()
	if err != nil {
		return false // Can't determine - assume not stale
	}
	return cmd != currentBinaryPath
}

// getWrapperBinaryPath extracts the BUMPER_BIN path from a wrapper script.
// Returns empty string if not found or on error.
func getWrapperBinaryPath(wrapperPath string) string {
	data, err := os.ReadFile(wrapperPath)
	if err != nil {
		return ""
	}
	const prefix = "# BUMPER_BIN: "
	for _, line := range strings.Split(string(data), "\n") {
		if strings.HasPrefix(line, prefix) {
			return strings.TrimPrefix(line, prefix)
		}
	}
	return ""
}

// isWrapperStale checks if the wrapper's embedded binary path differs from current.
// Returns true if wrapper should be regenerated.
func isWrapperStale(wrapperPath string) bool {
	embeddedPath := getWrapperBinaryPath(wrapperPath)
	if embeddedPath == "" {
		// No marker found (old wrapper format) - regenerate to add marker
		return true
	}
	currentPath := getBumperLanesBinPath()
	return embeddedPath != currentPath
}

// getOriginalCommand extracts the original status line command from a wrapper script.
// Returns empty string if not found or on error.
func getOriginalCommand(wrapperPath string) string {
	data, err := os.ReadFile(wrapperPath)
	if err != nil {
		return ""
	}
	const prefix = "# Original command: "
	for _, line := range strings.Split(string(data), "\n") {
		if strings.HasPrefix(line, prefix) {
			return strings.TrimPrefix(line, prefix)
		}
	}
	return ""
}

// generateWrapper creates the wrapper script at the given path.
func generateWrapper(wrapperPath, originalCmd, homeDir string) error {
	// Ensure .claude directory exists
	claudeDir := filepath.Dir(wrapperPath)
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		return err
	}

	// Get bumper-lanes binary path
	bumperBin := getBumperLanesBinPath()

	// Generate wrapper content
	// BUMPER_BIN marker enables staleness detection for auto-regeneration on plugin updates
	content := fmt.Sprintf(`#!/bin/bash
%s - DO NOT EDIT
# BUMPER_BIN: %s
# Wraps your status line to add bumper-lanes diff tree visualization.
# Original command: %s
# To remove: restore statusLine.command in ~/.claude/settings.json

set -euo pipefail

input=$(cat)

# Run original status line
echo "$input" | %s

# Append bumper-lanes widgets
indicator=$(echo "$input" | "%s" status --widget=indicator 2>/dev/null || true)
diff_tree=$(echo "$input" | "%s" status --widget=diff-tree 2>/dev/null || true)
[[ -n "$indicator" ]] && echo "$indicator"
[[ -n "$diff_tree" ]] && echo "$diff_tree"

exit 0
`, wrapperMarker, bumperBin, originalCmd, originalCmd, bumperBin, bumperBin)

	// Write and make executable
	if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
		return err
	}

	return nil
}

// updateSettingsWithJq updates ~/.claude/settings.json using jq.
func updateSettingsWithJq(homeDir, wrapperPath string) error {
	settingsPath := filepath.Join(homeDir, ".claude", "settings.json")

	// Check if jq is available
	if _, err := exec.LookPath("jq"); err != nil {
		return fmt.Errorf("jq not installed")
	}

	// Ensure settings.json exists
	if _, err := os.Stat(settingsPath); os.IsNotExist(err) {
		// Create minimal settings file
		if err := os.WriteFile(settingsPath, []byte("{}"), 0644); err != nil {
			return err
		}
	}

	// Use jq to update settings - must set both type and command
	jqExpr := fmt.Sprintf(`.statusLine.type = "command" | .statusLine.command = %q`, wrapperPath)
	cmd := exec.Command("jq", jqExpr, settingsPath)
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("jq failed: %w", err)
	}

	// Write back
	if err := os.WriteFile(settingsPath, output, 0644); err != nil {
		return err
	}

	return nil
}
